---
layout: post
title: 自產生程式（上）：自產生程式是什麼？謊話、罰寫、C 語言
---

## 問題敘述

> 試寫一段程式碼，會輸出自己的程式碼。沒有任何輸入。

這樣的程式稱為一個**自產生程式（Quine）**。Quine 一詞是美國科學家侯世達 (Douglas Hofstadter) 為記念邏輯學家奎因（Willard Van Orman Quine）所創。比起其他程式題目，譬如最短路徑、最大流、……這樣的問題敘述乍看之下或許有些含糊，就好像一個循環定義一般，不知從何著手。即便如此我們仍可以用最簡單的方法，試著找出解法。

以 C 語言為例，要印出自己，首先當然要寫一些開頭的束西：

{% highlight cpp linenos %}
#include <stdio.h>
int main() {
}
{% endhighlight %}

……再印程式的開頭……

{% highlight cpp linenos %}
#include <stdio.h>
int main() {
  printf("#include <stdio.h>\nint main() { ");
}
{% endhighlight %}

……再印出`printf()`的內容……

{% highlight cpp linenos %}
#include <stdio.h>
int main() {
  printf("#include <stdio.h>\nint main() { \n"
         "printf(\"#include <stdio.h>\\nint main() { \\n\n"
         "         \"printf(\\\"#include <stdio.h>\\\\nint main() { \\\\n\\n}"
         //......
         );
}
{% endhighlight %}

……就這麼無限遞迴下去。很顯然，最直接的方法在這裡是不可行的，但至少我們知道問題的困難點何在。

我們其實也已經知道這樣的問題有解。若逛一逛[維基百科的相關頁面](https://en.wikipedia.org/wiki/Quine_(computing))，就能發現許多語言的實作方法。如何思考這樣的問題呢？讓我們一同來瞧瞧。

## 問題試想：兩種「作弊」方法

第一個直覺的想法，程式碼如下：

```
```

什麼？這裡什麼都沒有啊？沒錯，因為什麼都沒有，所以它隨時都在執行，隨時都在輸出自己的程式碼，而且因為有總共○行，沒有任何方法比這個更簡潔啦。哇哈哈哈哈……

……咳咳，但這種腦筋急轉彎式的解答當然不是我們想要的，以下也不會針對這個程式繼續探討。下一位。

### 「作弊 Quine」

撇開上一個「做法」，另一個可行的想法如下：

1. 從硬碟把程式碼讀進程式中。
2. 把讀進來的程式碼一行一行輸出。

這個想法實作為 C 程式，並命名為 `quine_file.c` 即如下：

{% highlight cpp linenos %}
#include <stdio.h>
#include <stdlib.h>
int main() {
	FILE *f = fopen("quine_file.c","r");
	if (f != NULL) {
		char s[100];
		while(fgets(s, sizeof(s), f) != NULL) {
			fputs(s, stdout);
		}
		fclose(f);
	}
}
{% endhighlight %}

當然，這個方法有一些毛病：

* 程式碼改名便跑不動（我們當然也可以把第四行的檔名一同改掉）
* 我們也無法從其他資料夾執行
* 用到額外的資料，有些不優雅

這樣的自產生成式，稱為一個「作弊 Quine」(cheating Quine)，而唯一作弊的點就在於使用了程式以外的資料。但無疑的是，在正確的情況下，它已經能順利達到我們的目的。能不能從這個方法，慢慢改良、延伸到不用任何其他資料呢？為此，我們暫時放下程式語言，來想想看下面這個邏輯問題。

## 「這句話請寫一次」

「印出自己的程式碼」一事，如果用白話的方式呈現，也許相當於這樣的一句話：

> 這句話請寫一次。

如果有人「這句話請寫一次」真的寫了一次，那麼它就會被寫了一次，留下「這句話請寫一次」。這樣語意上指到自己的語句結構稱為**自指 (Self-referencing)**，在邏輯上可以用來製造悖論，如：

> 這句話是假話。

即有名的**說謊者悖論 (Liar's Paradox)**。

我們原本題目的困難點就在於沒有明顯的方法實現自指：電腦中有什麼樣的指令意思是「這個指令」？但使用作弊 Quine 的作法我們確實也做到了。利用的就是外部的資料。在這裡，我們仔細想一下，以上的程式執行時所發生的事情：

1. 首先，整段**程式碼**被編譯為一個*程式*。
2. *程式* 執行，並存取、輸出一段**程式碼**。

要寫出這樣的程式，顯然有兩個關鍵的元素：一是程式，二是程式碼。其中程式在記憶體中執行，程式碼則存在硬碟中。在我們的應用中，硬碟和記憶體的分別並不重要，可以想像是記憶體的延伸。因此，如果要把硬碟輸入部分從整個程式移除，理論上，我們需要想辦法把程式碼也放在記憶體中，並有辦法在程式執行時正確存取。然而以上都是硬體上面的討論。這究竟有沒有邏輯上更清晰，直覺的想法呢？

考慮以下這段白話的「指令」：

> 把下一句話寫兩次。把下一句話寫兩次。

如果有人照著做了，「把下一句話寫兩次」便會被寫兩次。我們於是使用了文字，寫出了輸出自己的一段指令了！照中文文法，第二個「把下一句話寫兩次」應該要加上引號才行。我們可以改成這樣：

> 把下一句話寫兩次，第二次加上引號。「把下一句話寫兩次，第二次加上引號。」

如果分析一下這段文字指令，我們能把它和前一個「作弊 Quine」作個連結：

* 第一句「把下一句話寫兩次，第二次加上引號。」是實際上執行的動作，就是作弊 Quine 中被編釋、執行的東西。
* 第二句加了引號的「把下一句話寫兩次，第二次加上引號。」是執行動作的說明，即作弊 Quine 中，存在硬碟中的程式碼。
* 第一句中的「下一句話」，則告訴我們「原始碼」的所在地。

有了引號，我們也可以把「原始碼」放到第一個位置：

> 「把上一句話寫兩次，第一次加上引號。」把上一句話寫兩次，第一次加上引號。

有兩件事情值得注意。一來當然是語序調換了，仍達到我們的目的。二來，在上一句話中，我們移除了「這句話請寫一次」中的自指，改為更具體的「上一句話」。第一句話因為是引述的句子，可以寫下任何內容而不用擔心其語意。當我們第二次說「把上一句話寫兩次」時，「上一句話」已經有了明確的定義。而這樣的結構，同樣跟一個悖論有異曲同工之妙：

>  「這樣一句話若寫兩次，且第一次加引號，就是句假話。」這樣一句話若寫兩次，且第一次加引號，就是句假話。

這個說謊者悖論的延伸稱作**奎因悖論 (Quine's Paradox)**。奎因以此指出，即使一段話沒有任何自指，仍然可以編出無法判斷真假的悖論，也是自產生程式的英文名字 Quine 的由來。事實上，自產生程式和悖論有著密切的關係，這些關係留待後面探討。

當然對於一個程式而言，「上一句話」這樣的指令還太含糊。但一步一步，我們能把原本的話改離自然語言，而更接近程式語言。在程式中，如果要指到其他的內容，使用的是變數。我們在白話中也可以引進變數的概念：

> S 代表 「把 S 寫兩次，第一次加上引號。」把 S 寫兩次，第一次加上引號。

或者：

> S 代表 「寫下SS，第一個 S 前後加上引號」寫下SS，第一個 S 前後加上引號。

寫到這裡，也許太多「S」讓人頭有點痛了。為了解釋清楚眾多的「S」，暫時回到程式語言的世界，考慮下面的程式：

{% highlight cpp %}
...
char S[] = "ST";
puts(S);
...
{% endhighlight %}

第一個 S 是變數名稱，第二個 S，即「ST」的「S」是字母 S，第三個 S 則是代表已經被賦值的變數 S。同樣地，引號內的 S 都指字母 S，但到了引號外則代表變數 S。

至此腦袋還清晰的讀者（相信我，我絕對不是這種讀者。這兩句話我來回編輯了好幾次……）就會發現，實際執行上面的口令，第一個會得到「「把 S 寫兩次，第一次加上引號。」把 S 寫兩次，第一次加上引號。」，第二個會得到「「寫下SS，第一個 S 前後加上引號」寫下SS，第一個 S 前後加上引號。」，兩個都少了最前面的「S 代表」。如果我們再引進一個變數 T，就能解決這個問題。

> S 代表「S 代表T把 S 寫一次，把第一個 T 換成 S，並加上引號。」把 S 寫一次，把第一個 T 換成 S，並加上引號。

思路有些跳躍，我們一步一步來看發生了什麼事：

1. 把 S 寫一次，得到「S 代表T把 S 寫一次，把第一個 T 換成 S，並加上引號。」

2. 把第一個 T 換成 S，得到「S 代表S 代表 T 把 S 寫一次，把第一個 T 換成 S，並加上引號。把 S 寫一次，把第一個 T 換成 S，並加上引號。」

3. 把（第一步的）T 加上引號，得到「S 代表「S 代表T 把 S 寫一次，把第一個 T 換成 S，並加上引號。」把 S 寫一次，把第一個 T 換成 S，並加上引號。」

在我們的口頭指令中，引號內並不符合文法，但在引號內都是引述的句子，可以打破中文的規則。我們再做最後一個變形：對於機器來說，「並加上引號」意思還太模糊：是加在前面？後面？加幾個？我們必須改成其他的說法。一個直覺的辦法是：

> S 代表「S 代表「T」把 S 寫一次，把第一個 T 換成 S。」把 S 寫一次，把第一個 T 換成 S。

這樣一來有個邏輯上的漏洞： 之前說引號內不帶任何語意，字母 T 就是字母 T，不是變數名稱，所以「第一個 T」指的其實是第一句中「把第一個 T 換成 S」的 T。如此一來，我們的口頭指令會變成輸出「S 代表「T」把 S 寫一次，把第一個 S 代表「T」把 S 寫一次，把第一個 T 換成 S。 換成 S。」，指令失敗。但是使用「並加上引號」並沒有這樣的問題。我們於是可以改成：

> S 代表「S 代表T把 S 寫一次，把第一個 T 換成 [左引號]S[右引號]。」把 S 寫一次，把第一個 T 換成 [左引號]S[右引號]。

這就是我們可以寫成程式的句型了。而我們仍可以注意到，這段指令前後若加上一些不影響輸出的句子，仍然可以達到我們的目的：

> 你好！S 代表「你好！S 代表T把 S 寫一次，把第一個 T 換成 [左引號]S[右引號]。再見！」把 S 寫一次，把第一個 T 換成 [左引號]S[右引號]。再見！

## 實作

講了許多的邏輯、變數、悖論，我們終於可以走出最後一大步，就是把上面的指令，用 C 實作，寫成下面這段程式：

{% highlight cpp linenos %}
char *s = "char *s = %c%s%c; int main() { printf(s,34,s,34); return 0; }"; int main() { printf(s,34,s,34); return 0; }
{% endhighlight %}

要知道的只有 34 是 ASCII 中的引號「"」，左右是一樣的。如此一來，我們就能類比整個程式和之前所談的口語指令了（在此忽略空白）：

{% highlight cpp %}
char *s =  "   char *s = %c%s%c; int main() { printf(s, 34,s,34);"
/*-------- --  --------- ------- ---------------------  ----------------------------
  S 代表   「   S 代表     T       把 T 寫一次             把第一個 T 換成[引號]S[引號]
*/

"return 0; } "; int main() { printf(s, 34,s,34);                    return 0; }
/*---------- -- ---------------------- ---------------------------- -----------
  再見！      」 把 T 寫一次              把第一個 T 換成[引號]S[引號]    再見！
*/
{% endhighlight %}

其實還有一些偷工減料的空間。如果硬擠出字串長度，還有以下這種非常簡潔的寫法：

{% highlight cpp linenos %}
char*s="char*s=%c%s%c;main(){printf(s,34,s,34);}";main(){printf(s,34,s,34);}
{% endhighlight %}

當然，一個正常的程式人，一定希望這個程式是能看的。至少不要擠在同一行，不要使用全域變數，加一下 `#include <stdio.h>` 。最大的困難在於換行，字串裡面表示成 `\n` 。但我們也可以使用和引號同樣的技巧輸出：

{% highlight cpp linenos %}
#include <stdio.h>
int main() { 
	char *s = "#include <stdio.h>%cint main() { %c%cchar *s = %c%s%c;%c%cprintf(s,10,10,9,34,s,34,10,9,10,9,10);%c%creturn 0;%c}";
	printf(s,10,10,9,34,s,34,10,9,10,9,10);
	return 0;
}
{% endhighlight %}

其中在 ASCII 裡，10 是換行，9 是 tab 鍵。如此一來，我們便從最開始的邏輯問題，一步步實現為程式碼了。

## 同場加映：銜尾蛇程式

使用相似的概念，我們也可以寫出一個「銜尾蛇程式」（Ouroboros）：程式 A 輸出一段程式 B，程式 B 又會輸出程式 A。若以 C、Python 3 兩個語言為例，便可寫出如下的程式。在 unix 環境下，若程式碼 `ouroboros.c` 編譯為執行檔 `ouroboros`，可以用 `./ouroboros | python3 | diff ouroboros.c -` 比對結果是否一樣。


{% highlight cpp linenos %}
#include <stdio.h>
int main() {
	char *a = "a = %c%s%c;%cb = %c%s%c;%cprint(a.format(b,a,chr(123),chr(125),chr(34),chr(10),chr(9)))",
	*b = "#include <stdio.h>{5}int main() {2}{5}{6}char *a = {4}{0}{4},{5}{6}*b = {4}{1}{4};{5}{6}printf(a,34,b,34,10,34,a,34,10);{5}{3}";
	printf(a,34,b,34,10,34,a,34,10);
}
{% endhighlight %}

而`ouroboros.c`的輸出則為：
{% highlight python linenos %}
a = "#include <stdio.h>{5}int main() {2}{5}{6}char *a = {4}{0}{4},{5}{6}*b = {4}{1}{4};{5}{6}printf(a,34,b,34,10,34,a,34,10);{5}{3}";
b = "a = %c%s%c;%cb = %c%s%c;%cprint(a.format(b,a,chr(123),chr(125),chr(34),chr(10),chr(9)))";
print(a.format(b,a,chr(123),chr(125),chr(34),chr(10),chr(9)))
{% endhighlight %}

至於詳細原理，以及之前提到 Quine 在邏輯上的應用，留待[下篇]({% post_url 2018-03-08-ouroboros %})分解。
