---
layout: post
title: 程式小特技 —— 以 C 語言實作自產生程式 (Quine)
---

## 前言

試寫一段程式碼，沒有任何輸入，輸出自己的程式碼。這樣的程式稱為一個**自產生程式（Quine）**。若逛一逛[維基百科的相關頁面](https://en.wikipedia.org/wiki/Quine_(computing))，就能發現許多語言的實作方法。如何思考這樣的問題呢？讓我們一同來瞧瞧。

## 問題試想：兩種「作弊 Quine」

第一個直覺的想法，程式碼如下：

```
```

什麼？這裡什麼都沒有啊？沒錯，因為什麼都沒有，所以它隨時都在執行，隨時都在輸出自己的程式碼，而且因為有零行，沒有任何方法比這個更簡潔啦。哇哈哈哈哈……

……咳咳，這種腦筋急轉彎跟下文無關，我只是想說沒漏掉這個想法而已。下一位。

### 第二種「作弊 Quine」

另一個，也許比第一個方法更為直覺的想法如下：

1. 從硬碟把程式碼讀進程式中。
2. 把讀進來的程式碼一行一行輸出。

這個想法實作為 C 程式，並命名為 `quine_file.c` 即如下：

{% highlight cpp linenos %}
#include <stdio.h>
#include <stdlib.h>
int main() {
	FILE *f = fopen("quine_file.c","r");
	if (f != NULL) {
		char s[100];
		while(fgets(s, sizeof(s), f) != NULL) {
			fputs(s, stdout);
		}
		fclose(f);
	}
}
{% endhighlight %}

當然，這個方法有一些毛病：

* 程式碼改名便跑不動（我們當然也可以把第四行的檔名一同改掉）
* 我們也無法從其他資料夾執行
* 用到硬碟額外的資料，難免有些不優雅（也造成以上的兩個問題）

但無疑的是，在正確的情況下，我們就能順利達到我們的目的。能不能從這個方法，慢慢改良、延伸到不用任何其他資料呢？

## 以口令發想

我們仔細想一下，以上的程式執行時所發生的事情：

1. 首先，整段**程式碼**被編譯為一個*程式*。
2. *程式*執行，並輸出**程式碼**

要寫出這樣的程式，顯然有兩個關鍵的元素：一是程式，二是程式碼。其中程式在記憶體中執行，程式碼則存在硬碟中。在我們的應用中，硬碟和記憶體的分別並不重要，可以想像是記憶體的延伸。因此，如果要把硬碟輸入部分從整個程式移除，理論上，我們需要想辦法把程式碼也放在記憶體中，並有辦法在程式執行時正確存取。然而以上都是硬體上面的討論。這究竟有沒有邏輯上更清晰，直覺的想法呢？

考慮以下這段白話的「指令」：

> 把下一句話寫兩次。把下一句話寫兩次。

如果有人照著做了，「把下一句話寫兩次」便會被寫兩次。我們於是使用了文字，寫出了輸出自己的一段指令了！照中文文法，，第二個「把下一句話寫兩次」應該要加上引號才行。我們可以改成這樣：

> 把下一句話寫兩次，第二次加上引號。「把下一句話寫兩次，第二次加上引號。」

如果分析一下這段文字指令，我們能把它和前一個「作弊 Quine」作個連結：

* 第一句「把下一句話寫兩次，第二次加上引號。」是實際上執行的動作，就是作弊 Quine 中被編釋、執行的東西。
* 第二句加了引號的「把下一句話寫兩次，第二次加上引號。」是執行動作的說明，即作弊 Quine 中，存在硬碟中的程式碼。
* 第一句中的「下一句話」，則告訴我們「原始碼」的所在地。

有了引號，我們也可以把「原始碼」放到第一個位置：

> 「把上一句話寫兩次，第一次加上引號。」把上一句話寫兩次，第一次加上引號。

當然，程式裡面很少有「上一句話」這樣的指令。但一步一步，我們能把原本的話改離自然語言，而更接近程式語言。此時我們引進變數的概念：

> S 代表 「把 S 寫兩次，第一次加上引號。」把 S 寫兩次，第一次加上引號。

或者：

> S 代表 「寫下SS，第一個 S 前後加上引號」寫下SS，第一個 S 前後加上引號。

寫到這裡，也許太多「S」讓人頭有點痛了。這邊暫時回到程式語言的世界，考慮下面的程式：

{% highlight cpp %}
...
char S[] = "ST";
puts(S);
...
{% endhighlight %}

第一個 S 是變數名稱，第二個 S，即「ST」的「S」是字母 S，第三個 S 則是代表已經被賦值的變數 S。同樣地，引號內的 S 都指字母 S，但到了引號外則代表變數 S。

實際執行上面的口令，第一個會得到「「把 S 寫兩次，第一次加上引號。」把 S 寫兩次，第一次加上引號。」，第二個會得到「「寫下SS，第一個 S 前後加上引號」寫下SS，第一個 S 前後加上引號。」，兩個都少了最前面的「S 代表」。如果我們再引進一個變數 T，就能解決這個問題。

> S 代表「S 代表T把 S 寫一次，把第一個 T 換成 S，並加上引號。」把 S 寫一次，把第一個 T 換成 S，並加上引號。

思路有些跳躍，我們一步一步來看發生了什麼事：

1. 把 S 寫一次，得到「S 代表T把 S 寫一次，把第一個 T 換成 S，並加上引號。」
2. 把第一個 T 換成 S，得到「S 代表S 代表 T 把 S 寫一次，把第一個 T 換成 S，並加上引號。把 S 寫一次，把第一個 T 換成 S，並加上引號。」
3. 把（第一步的）T 加上引號，得到「S 代表「S 代表T 把 S 寫一次，把第一個 T 換成 S，並加上引號。」把 S 寫一次，把第一個 T 換成 S，並加上引號。」

在我們的口頭指令中，引號內並不符合文法，但在引號中便能打破這些規則。

至此我們再做最後一個變形：對於機器來說，「並加上引號」意思還太模糊，必須改成其他的說法。一個直覺的辦法是：

> S 代表「S 代表「T」把 S 寫一次，把第一個 T 換成 S。」把 S 寫一次，把第一個 T 換成 S。

這樣一來有個邏輯上的漏洞： 之前說引號內不帶任何語意，字母 T 就是字母 T，不是變數名稱。如此一來，我們的口頭指令會變成輸出「S 代表「T」把 S 寫一次，把第一個 S 代表「T」把 S 寫一次，把第一個 T 換成 S。 換成 S。」，指令失敗。但是使用「並加上引號」並沒有這樣的問題。我們於是可以改成：

> S 代表「S 代表T把 S 寫一次，把第一個 T 換成 [左引號]S[右引號]。」把 S 寫一次，把第一個 T 換成 [左引號]S[右引號]。

這就是我們可以寫成程式的句型了。而我們仍可以注意到，這段指令前後若加上一些不影響輸出的句子，仍然可以達到我們的目的：

> 你好！S 代表「你好！S 代表T把 S 寫一次，把第一個 T 換成 [左引號]S[右引號]。再見！」把 S 寫一次，把第一個 T 換成 [左引號]S[右引號]。再見！

## 實作

我們從最少字但最難讀的做法開始：

{% highlight cpp linenos %}
char*s="char*s=%c%s%c;main(){printf(s,34,s,34);}";main(){printf(s,34,s,34);}
{% endhighlight %}

運用上面的原則，我能做出最短的 Quine 就是這樣了。而排板稍好，`main()`再加上 `int` 和 `return 0;` 的版本則如下：

{% highlight cpp linenos %}
char *s = "char *s = %c%s%c; int main() { printf(s,34,s,34); return 0; }"; int main() { printf(s,34,s,34); return 0; }
{% endhighlight %}

其中 34 是 ASCII 中的引號「"」，左右是一樣的。如此一來，我們就能類比整個程式和之前所談的口語指令了（在此忽略空白）：

{% highlight cpp %}
char *s =  "   char *s = %c%s%c; int main() { printf(s, 34,s,34);"
/*-------- --  --------- ------- ---------------------  ----------------------------
S 代表     「  S 代表    T       把 T 寫一次            把第一個 T 換成[引號]S[引號]
*/

"return 0; } "; int main() { printf(s, 34,s,34);                    return 0; }
/*--------- -- ---------------------- ---------------------------- -----------
再見！      」 把 T 寫一次            把第一個 T 換成[引號]S[引號] 再見！
*/
{% endhighlight %}

一個正常的程式人，一定希望這個程式是能看的，至少不要擠在同一行，不要使用全域變數，加一下 `#include <stdio.h>` 。最大的困難在於換行，字串裡面表示成 `\n` 。但這也代表我們可以使用和引號同樣的技巧：

{% highlight cpp linenos %}
#include <stdio.h>
int main() { 
	char *s = "#include <stdio.h>%cint main() { %c%cchar *s = %c%s%c;%c%cprintf(s,10,10,9,34,s,34,10,9,10,9,10);%c%creturn 0;%c}";
	printf(s,10,10,9,34,s,34,10,9,10,9,10);
	return 0;
}
{% endhighlight %}

ASCII中，10 是換行，9 是 tab。

## 同場加映：銜尾蛇程式
使用相似的概念，我們也可以寫出一個「銜尾蛇程式」（Ouroboros）：程式 A 輸出一段程式 B，程式 B 又會輸出程式 A。若以 C、Python 3 兩個語言為例，便可寫出如下的程式。在 unix 環境下，若程式碼 `ouroboros.c` 編譯為執行檔 `ouroboros`，可以用 `./ouroboros | python3 | diff ouroboros.c -` 比對結果是否一樣。

至於詳細原理，留待下篇分解。

{% highlight cpp linenos %}
#include <stdio.h>
int main() {
	char *a = "a = %c%s%c;%cb = %c%s%c;%cprint(a.format(b,a,chr(123),chr(125),chr(34),chr(10),chr(9)))",
	*b = "#include <stdio.h>{5}int main() {2}{5}{6}char *a = {4}{0}{4},{5}{6}*b = {4}{1}{4};{5}{6}printf(a,34,b,34,10,34,a,34,10);{5}{3}";
	printf(a,34,b,34,10,34,a,34,10);
}
{% endhighlight %}

而`ouroboros.c`的輸出則為：
{% highlight python linenos %}
a = "#include <stdio.h>{5}int main() {2}{5}{6}char *a = {4}{0}{4},{5}{6}*b = {4}{1}{4};{5}{6}printf(a,34,b,34,10,34,a,34,10);{5}{3}";
b = "a = %c%s%c;%cb = %c%s%c;%cprint(a.format(b,a,chr(123),chr(125),chr(34),chr(10),chr(9)))";
print(a.format(b,a,chr(123),chr(125),chr(34),chr(10),chr(9)))
{% endhighlight %}

## 實用功能
無。
